#!/usr/bin/env bash
set -e
shopt -s globstar

# Copyright Â© 2018-2019 JPCDI, JPartain89 and Justin Partain
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This script is for looking through my media files for any MKV
# files and:
## - Send them to Subler using Apple's Applescript Automation Language
## - Simply List them
## - Delete them (I don't suggest using this, as its had a habit of erasing all
###  of the directory....)

# Program information
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROGRAM_NAME="mkvnmp4"
VERSION="4.5.0"

die() {
    echo "$PROGRAM_NAME: $1" >&2
    exit "${2:-1}"
}

command -v "$PROGRAM_NAME" 1>/dev/null 2>&1 || {
    (
        if [ -x "${DIR}/${PROGRAM_NAME}" ]; then
            sudo ln -svf "${DIR}/${PROGRAM_NAME}" "/usr/local/bin/${PROGRAM_NAME}"
            sudo chmod -R 0775 "/usr/local/bin/${PROGRAM_NAME}"
        else
            echo "For some reason, linking $PROGRAM_NAME to /usr/local/bin,"
            echo "failed. My apologies for not being able to figure it out..."
            exit 1
        fi
    )
}

if [ -f /etc/mkvnmp4.conf ]; then
    . /etc/mkvnmp4.conf
elif [ -f ~/.mkvnmp4.conf ]; then
    . ~/.mkvnmp4.conf
elif [ -f ~/.config/mkvnmp4.conf ]; then
    . ~/.config/mkvnmp4.conf
else
    die << EOF
We couldn't find the mkvnmp4.conf configuration file that we require to run!
The file is looked for at:

    /etc/mkvnmp4.conf
            - or -
    ~/.mkvnmp4.conf
            - or -
    ~/.config/mkvnmp4.conf

This repo has a configuration file example that you can key off of for what you need to fill out.

Exiting now.
EOF
    exit 1
fi

# This tests for gnu-getopt, as thats needed to run
if [ -f /usr/local/opt/gnu-getopt/bin/getopt ]; then
    GETOPT="/usr/local/opt/gnu-getopt/bin/getopt"
    if [ $("$GETOPT" --test; echo $?) != 4 ]; then
        die "You seem to have the wrong version of gnu-getopt?
        Please investigate and have the proper one installed."
    fi
else
    die "Seems you're missing the required gnu-getopt program.
    Please install using brew install gnu-getopt."
fi

if [[ "$(uname)" == "Darwin" ]]; then
    COUNTER=0
    for f in "${PornDrive}" "${MovieDrive}" "${TVDrive}" "${OtherDrive}"; do
        if [ -d "$f" ]; then
            COUNTER=$[ $COUNTER +1 ]
        fi
        if [ $COUNTER == 0 ]; then
            die "Your configured drives are not present.
            You need to get the drives mounted before we can continue."
        fi
    done
    unset f
    unset COUNTER
else
    die "Currently, only meant for macOS."
fi


if [ $# == -v ]; then
    TV_EXT="${TVDrive:-OtherDrive}/*/*/*" 2>/dev/null
    MOVIES_EXT="${MovieDrive:-OtherDrive}/*/*/*" 2/dev/null
    PORN_EXT="${PornDrive:-OtherDrive}/*/*/*" 2>/dev/null
else
    TV_EXT="${TVDrive:-OtherDrive}/*/*/*"
    MOVIES_EXT="${MovieDrive:-OtherDrive}/*/*/*"
    PORN_EXT="${PornDrive:-OtherDrive}/*/*/*"
fi

TIMEOUT_WAIT="${WAIT_TIMEOUT:-600}"

RED=$(tput setaf 1)
NORMAL=$(tput sgr 0)

press_enter() {
    echo ""
    echo -n "Press Enter to Continue..."
    read -r
}

# These are declaring our command line flags for getopt lower down
SHORT=swh
LONG=send,wait,rm,dup,help

USAGE() {
cat << EOF
${PROGRAM_NAME} [ -s | --send ] or  [ -w | -- wait ]
                [ --rm ]
                [ --dup ]
                [ -h | --help ]

      -s | --send : Send to Subler
            -- or --
      -w | --wait : Tells Subler to wait between jobs in order to auto
                  : delete the duplicates.
                  : Much safer than -rm below.

        -rm       : Remove duplicate MKV's that also have mp4
        -dup      : Show Duplicates
      -h | --help : This Help

    This program is to send found mkv files to Subler using Apple's AppleScript automation backend.
    When using -w or  --wait, the program will sit and wait until the current item is being processed in Subler.
    You can change the default length of time it waits in the above configuration file using WAIT_TIMEOUT=600 - and it is in seconds.
EOF
}

# The find commands, at this point, need to stay separate due to
# the fact that the testing lines were still operating even if
# the mp4's already existed

# Having separated them out, the process now takes - literally - twice
# as long to process. But, for now, thats just fine.

# This is the entire find command line for`mkv`
findCMDmkv() {
    find -s "${f}" -maxdepth 4 -type f -iname "*.mkv"  -exec echo {} \;
}
# This is the entire find command line for `m4v`
findCMDm4v() {
    find -s "${f}" -maxdepth 4 -type f -iname "*.m4v"  -exec echo {} \;
}

outputMKVFiles() {
    while IFS= read -r file; do
        y="${file%.mkv}.mp4"
        if [[ ! -e ${y} ]]; then
            echo ""
            echo "$file"
        else
            echo ""
            echo "$file"
        fi
    done < <(findCMDmkv)
    while IFS= read -r file; do
        y="${file%.m4v}.mp4"
        if [[ ! -e ${y} ]]; then
            echo ""
            echo "$file"
        else
            echo ""
            echo "$file"
        fi
    done < <(findCMDm4v)
}

outputToSubler_NoWait() {
    # This bit of scripting runs through AppleScript to Subler
    for f in $TV_EXT $MOVIES_EXT $PORN_EXT; do echo "${f}";
    while IFS= read -r file; do
        y="${file%.mkv}.mp4"
        if [[ ! -e ${y} ]]; then
            echo ""
            echo "$file ${RED}<--THIS ONE${NORMAL}"
            osascript -e "
                set filePath to (POSIX file \"$file\" as alias)
                tell application \"Subler\"
                    add to queue filePath
                    start queue
                end tell"
        fi
    done < <(findCMDmkv)
    unset y
    while IFS= read -r file; do
        y="${file%.m4v}.mp4"
        if [[ ! -e ${y} ]]; then
            echo ""
            echo "$file ${RED}<--THIS ONE${NORMAL}"
            osascript -e "
            set filePath to (POSIX file \"$file\" as alias)
            tell application \"Subler\"
                add to queue filePath
                start queue
            end tell"
        fi
    done < <(findCMDm4v)
    unset y
    done
}

outputToSubler_Wait() {
    # This bit of scripting runs through AppleScript to Subler
    for f in $TV_EXT $MOVIES_EXT $PORN_EXT; do echo "${f}";
    while IFS= read -r file; do
        y="${file%.mkv}.mp4"
        if [[ ! -e ${y} ]]; then
            echo ""
            echo "$file ${RED}<--THIS ONE${NORMAL}"
            osascript -e "
                set filePath to (POSIX file \"$file\" as alias)
                tell application \"Subler\"
                    with timeout of '$TIMEOUT_WAIT' seconds
                    add to queue filePath
                    start queue and wait
                    tell application \"Finder\"
                        if exists file filePath then
                            delete file filePath
                        end if
                    end tell
                    end timeout
                end tell"
        fi
    done < <(findCMDmkv)
    unset y
    while IFS= read -r file; do
        y="${file%.m4v}.mp4"
        if [[ ! -e ${y} ]]; then
            echo ""
            echo "$file ${RED}<--THIS ONE${NORMAL}"
            osascript -e "
            set filePath to (POSIX file \"$file\" as alias)
            tell application \"Subler\"
                with timeout of '$TIMEOUT_WAIT' seconds
                add to queue filePath
                start queue and wait
                tell application \"Finder\"
                    if exists file filePath then
                        delete file filePath
                    end if
                end timeout
                end tell
            end tell"
        fi
    done < <(findCMDm4v)
    unset y
    done
}

CONFIRM_DEL() {
    while IFS= read -r file; do
        y="${file%.mkv}.mp4"
        if [[ -e ${y} ]]; then
            echo "${RED}Erasing ${file}....${NORMAL}"
            echo ""
            rm -f "$file" ;
        fi
    done < <(findCMDmkv)
    unset y

    while IFS= read -r file; do
        y="${file%.m4v}.mp4"
        if [[ -e ${y} ]]; then
            echo "${RED}Erasing ${file}....${NORMAL}"
            echo ""
            rm -f "$file" ;
        fi
    done < <(findCMDm4v)
    unset y
}

SHOW_OUTPUT() {
    while IFS= read -r file; do
        y="${file%.mkv}.mp4"
        if [[ ! -e ${y} ]]; then

            cat <<EOF
###########################################################
${RED}$file ${NORMAL}
${file%.mkv}.mp4
###########################################################
EOF

        fi
    done < <(findCMDmkv)
    unset y

    while IFS= read -r file; do
        y="${file%.m4v}.mp4"
        if [[ ! -e ${y} ]]; then

            cat <<EOF
###########################################################
${RED}$file ${NORMAL}
${file%.m4v}.mp4
###########################################################
EOF

        fi
    done < <(findCMDm4v)
    unset y
}

kSHOW_OUTPUT() {
    if [[ $(SHOW_OUTPUT) != "" ]]; then
cat << EOF

Please, examine the above files to confirm they are ready to be removed.

The next step is ${RED}"nuclear"${NORMAL}, as there is no going back after files are deleted.
Usually....

EOF
        press_enter &&
        CONFIRM_DEL &&
        echo "Finished Deleting...."
        echo ""
    fi
}

trap 'die 1' SIGHUP SIGINT SIGTERM

finalDelete() {
    for f in $TV_EXT $MOVIES_EXT $PORN_EXT; do
        echo "${f}";
        SHOW_OUTPUT;
        kSHOW_OUTPUT;
    done
}

showMKVFiles() {
    for f in $TV_EXT $MOVIES_EXT $PORN_EXT; do
        outputMKVFiles;
    done
}

OPTS=$(${GETOPT} --options $SHORT --long $LONG --name "$0" -- "$@")

if [ $? != 0 ] ; then
    die "Failed to parse options...exiting." >&2
fi

eval set -- "$OPTS"

while true; do
    case "$1" in
        -h | --help )
            USAGE
            exit 0
            ;;
        -s | --send )
            outputToSubler_NoWait
            exit 0
            ;;
        -w | --wait )
            outputToSubler_Wait
            exit 0
            ;;
        --rm )
            finalDelete
            exit 0
            ;;
        --dup )
            showMKVFiles
            exit 0
            ;;
        -h | --help )
            USAGE
            exit 0
            ;;
        -- )
            shift
            break
            ;;
        * )
            die "Received invalid option. Sorry!"
            ;;
    esac
done

exit 0
