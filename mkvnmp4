#!/usr/bin/env bash
set -e
shopt -s globstar

# Copyright Â© 2018-2019 JPCDI, JPartain89 and Justin Partain
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This script is for looking through my media files for any MKV
# files and:
## - Send them to Subler using Apple's Applescript Automation Language
## - Simply List them
## - Delete them (I don't suggest using this, as its had a habit of erasing all
###  of the directory....)

# Program information
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROGRAM_NAME="mkvnmp4"
VERSION="4.0.0"

command -v "$PROGRAM_NAME" 1>/dev/null 2>&1 || {
    (
        if [ -x "${DIR}/${PROGRAM_NAME}" ]; then
            sudo ln -svf "${DIR}/${PROGRAM_NAME}" "/usr/local/bin/${PROGRAM_NAME}"
            sudo chmod -R 0775 "/usr/local/bin/${PROGRAM_NAME}"
        else
            echo "For some reason, linking $PROGRAM_NAME to /usr/local/bin,"
            echo "failed. My apologies for not being able to figure it out..."
            exit 1
        fi
    )
}

if [ -f /etc/mkvnmp4.conf ]; then
    . /etc/mkvnmp4.conf
elif [ -f ~/.mkvnmp4.conf ]; then
    . ~/.mkvnmp4.conf
elif [ -f ~/.config/mkvnmp4.conf ]; then
    . ~/.config/mkvnmp4.conf
else
    cat << EOF
We couldn't find the mkvnmp4.conf configuration file that we require to run!
The file is looked for at:

    /etc/mkvnmp4.conf
            - or -
    ~/.mkvnmp4.conf
            - or -
    ~/.config/mkvnmp4.conf

This repo has a configuration file example that you can key off of for what you need to fill out.

Exiting now.
EOF
    exit 1
fi

if [[ "$(uname)" == "Darwin" ]]; then
    if [ -d "${PornDrive}" ] || [ -d "${MovieDrive}" ]  || [ -d "${TVDrive}" ] || [ -d "${OtherDrive}" ]; then
        true
    else
        echo "Your configured drives are not present."
        echo "You need to get the drives mounted before we can continue."
        exit 1
    fi
else
    echo "Currently, only meant for macOS."
    exit 1
fi

if [ $# == -v ]; then
    TV_EXT="${TVDrive:-OtherDrive}/*/*/*" 2>/dev/null
    MOVIES_EXT="${MovieDrive:-OtherDrive}/*/*/*" 2/dev/null
    PORN_EXT="${PornDrive:-OtherDrive}/*/*/*" 2>/dev/null
else
    TV_EXT="${TVDrive:-OtherDrive}"
    MOVIES_EXT="${MovieDrive:-OtherDrive}"
    PORN_EXT="${PornDrive:-OtherDrive}"
fi

RED=$(tput setaf 1)
NORMAL=$(tput sgr 0)

press_enter() {
    echo ""
    echo -n "Press Enter to Continue..."
    read -r
}

USAGE() {
cat << EOF
${PROGRAM_NAME}

    This program is to remove the duplicated .mkv files when the corresponding .mp4 file is present.

${RED}Currently, this does not make sure the new, .mp4 version is not currently being worked on - duplicated from the .mkv - or even correctly sourced from the .mkv.

            MAKE SURE TO DOUBLE CHECK FIRST!${NORMAL}
EOF
}

# The find commands, at this point, need to stay separate due to
# the fact that the testing lines were still operating even if
# the mp4's already existed

# Having separated them out, the process now takes - literally - twice
# as long to process. But, for now, thats just fine.

# This is the entire find command line for`mkv`
findCMDmkv() {
    find -s "${f}" -maxdepth 4 -type f -iname "*.mkv"  -exec echo {} \;
}
# This is the entire find command line for `m4v`
findCMDm4v() {
    find -s "${f}" -maxdepth 4 -type f -iname "*.m4v"  -exec echo {} \;
}

outputMKVFiles() {
        while IFS= read -r file; do
            y="${file%.mkv}.mp4"
            if [[ ! -e ${y} ]]; then
                echo ""
                echo "$file"
            else
                echo ""
                echo "$file"
            fi
        done < <(findCMDmkv)
        while IFS= read -r file; do
            y="${file%.m4v}.mp4"
            if [[ ! -e ${y} ]]; then
                echo ""
                echo "$file"
            else
                echo ""
                echo "$file"
            fi
        done < <(findCMDm4v)
}

outputToSubler() {
    # This bit of scripting runs through AppleScript to Subler
    while IFS= read -r file; do
        y="${file%.mkv}.mp4"
        if [[ ! -e ${y} ]]; then
            echo ""
            echo "$file ${RED}<--THIS ONE${NORMAL}"
            osascript -e "
                set filePath to (POSIX file \"$file\" as alias)
                tell application \"Subler\"
                    add to queue filePath
                    start queue and wait
                    tell application \"Finder\"
                        if exists file filePath then
                            delete file filePath
                        end if
                    end tell
                end tell"
        fi
    done < <(findCMDmkv)
    unset y
    while IFS= read -r file; do
        y="${file%.m4v}.mp4"
        if [[ ! -e ${y} ]]; then
            echo ""
            echo "$file ${RED}<--THIS ONE${NORMAL}"
            osascript -e "
            set filePath to (POSIX file \"$file\" as alias)
            tell application \"Subler\"
                add to queue filePath
                start queue and wait
                tell application \"Finder\"
                    if exists file filePath then
                        delete file filePath
                    end if
                end tell
            end tell"
        fi
    done < <(findCMDm4v)
    unset y
}

CONFIRM_DEL() {
    while IFS= read -r file; do
        y="${file%.mkv}.mp4"
        if [[ -e ${y} ]]; then
            echo "${RED}Erasing ${file}....${NORMAL}"
            echo ""
            rm -f "$file" ;
        fi
    done < <(findCMDmkv)
    unset y

    while IFS= read -r file; do
        y="${file%.m4v}.mp4"
        if [[ -e ${y} ]]; then
            echo "${RED}Erasing ${file}....${NORMAL}"
            echo ""
            rm -f "$file" ;
        fi
    done < <(findCMDm4v)
    unset y
}

SHOW_OUTPUT() {
    while IFS= read -r file; do
        y="${file%.mkv}.mp4"
        if [[ ! -e ${y} ]]; then

            cat <<EOF
###########################################################
${RED}$file ${NORMAL}
${file%.mkv}.mp4
###########################################################
EOF

        fi
    done < <(findCMDmkv)
    unset y

    while IFS= read -r file; do
        y="${file%.m4v}.mp4"
        if [[ ! -e ${y} ]]; then

            cat <<EOF
###########################################################
${RED}$file ${NORMAL}
${file%.m4v}.mp4
###########################################################
EOF

        fi
    done < <(findCMDm4v)
    unset y
}

kSHOW_OUTPUT() {
    if [[ $(SHOW_OUTPUT) != "" ]]; then
cat << EOF

Please, examine the above files to confirm they are ready to be removed.

The next step is ${RED}"nuclear"${NORMAL}, as there is no going back after files are deleted.
Usually....

EOF
        press_enter &&
        CONFIRM_DEL &&
        echo "Finished Deleting...."
        echo ""
    fi
}

trap 'exit 1' SIGHUP SIGINT SIGTERM

finalDelete() {
    for f in $TV_EXT $MOVIES_EXT $PORN_EXT; do
        echo "${f}";
        SHOW_OUTPUT;
        kSHOW_OUTPUT;
    done
}

sendToSubler() {
    for f in $TV_EXT $MOVIES_EXT $PORN_EXT; do
        echo "${f}";
        outputToSubler;
    done
}

showMKVFiles() {
    for f in $TV_EXT $MOVIES_EXT $PORN_EXT; do
        outputMKVFiles;
    done
}

while getopts ":hSds" opt; do
    case ${opt} in
        h )
            USAGE
            exit 0
            ;;
        S )
            sendToSubler
            exit 0
            ;;
        d )
            finalDelete
            exit 0
            ;;
        s )
            showMKVFiles
            exit 0
            ;;
        \? )
            echo "Invalid Option: -$OPTARG" 1>&2
            exit 1
            ;;
    esac
done
shift $((OPTIND -1))

exit 0
